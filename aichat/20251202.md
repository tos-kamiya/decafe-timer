# カウントダウンタイマー作成

**User:** Toshihiro Kamiya (tos.kamiya@gmail.com)  
**Created:** 12/2/2025 16:58:14  
**Updated:** 12/2/2025 17:27:59  
**Exported:** 12/2/2025 17:28:22  
**Link:** [https://chatgpt.com/c/692e9b79-62b0-8324-b557-0a00c0ef484b](https://chatgpt.com/c/692e9b79-62b0-8324-b557-0a00c0ef484b)  

## Prompt:
コーヒーを飲むタイミングを制御するようのタイマーがほしいです。
基本的には、
* 時間を指定してカウントダウン
* 0になったら停止
としたいと思います。また、OSを再起動しても大丈夫なように、1分に1回くらい、設定ファイルに現在時刻を記録したいです。
OSの再起動に掛かった時間もカウントダウンに含めてください。
例えば、表示が2:00:00（残り2時間）とのき、OSを再起動に2分掛かったとすると、彩度起動したときの表示は1:58:00にしたいです。

## Response:
以下のような仕様で実装すると、**OS再起動の影響を受けずに正しく残り時間を計算できるカウントダウンタイマー**が作れます。  
Python での実装例も載せるので、そのままスクリプトとして使えます。

* * *

🕒 要件の整理
========

1.  **開始時に任意の時間（例：2時間）をセット**
2.  カウントダウン開始
3.  **1分に1回、設定ファイルへ状態を保存**
    *   残り時間ではなく、\*\*「終了予定時刻」\*\*を書いておくのが安定
    *   記録内容：`finish_at = start_time + duration`
4.  OS再起動後は
    *   設定ファイルから `finish_at` を読み、
    *   `remaining = finish_at - now`
    *   これが負なら「終了済み」
5.  表示は 1 秒ごとでも、10 秒ごとでも任意
6.  OS再起動に2分かかっても、自動的に残り時間から引かれて正しく表示される

* * *

📝 なぜ「終了予定時刻」を保存するのか？
=====================

*   「残り時間」を保存してしまうと、  
    → 再起動中の経過時間を引くことが難しい
*   代わりに「終了時刻」を保存しておけば、  
    → `remaining = finish_at - 現在時刻` で確実に計算できる
*   有名なタイマーアプリも大半がこの方式です。

* * *

🧪 Python実装例（ファイル永続化付きカウントダウンタイマー）
==================================

以下は **Linux/macOS/Windows** で動きます。

保存される設定ファイル：`timer_state.json`  
（場所はスクリプトと同じフォルダ）

```python
import json
import time
from datetime import datetime, timedelta
from pathlib import Path

STATE_FILE = Path("timer_state.json")

def save_finish_time(finish_at: datetime):
    data = {"finish_at": finish_at.isoformat()}
    STATE_FILE.write_text(json.dumps(data))

def load_finish_time():
    if not STATE_FILE.exists():
        return None
    try:
        data = json.loads(STATE_FILE.read_text())
        return datetime.fromisoformat(data["finish_at"])
    except Exception:
        return None

def start_timer(hours=0, minutes=0, seconds=0):
    duration = timedelta(hours=hours, minutes=minutes, seconds=seconds)
    finish_at = datetime.now() + duration
    save_finish_time(finish_at)
    print(f"Timer started. It will finish at {finish_at}")
    run_timer_loop()

def run_timer_loop():
    while True:
        finish_at = load_finish_time()
        if finish_at is None:
            print("No timer active.")
            break

        now = datetime.now()
        remaining = finish_at - now

        if remaining <= timedelta(0):
            print("\rTime's up!              ")
            STATE_FILE.unlink(missing_ok=True)  # 終了したらファイル削除
            break

        # 残り時間を表示
        total_sec = int(remaining.total_seconds())
        h = total_sec // 3600
        m = (total_sec % 3600) // 60
        s = total_sec % 60
        print(f"\rRemaining: {h:02d}:{m:02d}:{s:02d}", end="")

        # 1分に1回ファイル更新
        if now.second == 0:
            save_finish_time(finish_at)

        time.sleep(1)  # 1秒に1回更新

def resume_timer():
    finish_at = load_finish_time()
    if finish_at is None:
        print("No active timer.")
        return
    print(f"Resuming timer. It will finish at {finish_at}")
    run_timer_loop()

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument("--start", nargs=1)
    args = parser.parse_args()

    if args.start:
        # 例: --start 2:00:00
        h, m, s = map(int, args.start[0].split(":"))
        start_timer(hours=h, minutes=m, seconds=s)
    else:
        resume_timer()
```

* * *

💡 使い方（コマンド例）
=============

❶ 新規タイマー開始
----------

```
python timer.py --start 2:00:00
```

→ 2時間後に終了  
→ 1分に1回、`timer_state.json` に終了時刻を記録

❷ 再起動後に自動で再開
------------

```
python timer.py
```

→ `timer_state.json` があれば再開  
→ OS再起動で2分経過していたら、その分だけ残りが減る

* * *

☕ このタイマーの応用
===========

*   コーヒーの「次に飲んでよいまでの間隔」を守る
*   カフェイン中毒対策として「あと何分で飲めるか」表示
*   1日を通して複数の間隔タイマーを管理
*   終了時に音を鳴らす／通知する

必要なら、  
🔔 **通知音をつける**  
📱 **Linuxサービス(systemd)として常駐させる**  
🖥 **GUI化（Tkinter/PyQt）**  
🧪 **複数並列タイマーを管理**  
なども作れます。

* * *

こういう仕様で合っていますか？  
追加の要望（音、常駐、GUI など）があれば、どんどん教えてください。

## Prompt:
ありがとうございます。
appdirsを用いてキャッシュファイルに時刻を記録するようにしてください。
数字の下に棒グラフをつけて、だんだん短くなるようにしてください。ANSIエスケープシーケンスでできるでしょうか。

## Response:
思考時間: 1m 13s

いいですね、「コーヒー解禁まであと◯分」のタイマー ☕  
`appdirs` を使って OS をまたいでもちゃんと続きができて、表示の下にだんだん短くなる棒グラフを ANSI で出す版を書いてみます。

* * *

前提
--

*   Python 3.8 以降くらいを想定
*   事前に `appdirs` をインストールしてください：

```bash
pip install appdirs
```

* * *

コード全体
-----

```python
import json
import time
from datetime import datetime, timedelta
from pathlib import Path

from appdirs import user_cache_dir

APP_NAME = "coffee_timer"
APP_AUTHOR = "example"  # お好みでユーザー名などに変更可

CACHE_DIR = Path(user_cache_dir(APP_NAME, APP_AUTHOR))
STATE_FILE = CACHE_DIR / "timer_state.json"

def save_state(finish_at: datetime, duration_sec: int):
    """終了予定時刻と元の総時間、そして現在時刻をキャッシュに保存"""
    CACHE_DIR.mkdir(parents=True, exist_ok=True)
    now = datetime.now()
    data = {
        "finish_at": finish_at.isoformat(),
        "duration_sec": duration_sec,
        "last_saved_at": now.isoformat(),  # 要件どおり「現在時刻」も記録
    }
    STATE_FILE.write_text(json.dumps(data))

def load_state():
    """キャッシュから終了予定時刻と総時間を読み出す"""
    if not STATE_FILE.exists():
        return None
    try:
        data = json.loads(STATE_FILE.read_text())
        finish_at = datetime.fromisoformat(data["finish_at"])
        duration_sec = int(data["duration_sec"])
        return finish_at, duration_sec
    except Exception:
        return None

def format_bar(remaining_sec: int, duration_sec: int, width: int = 30) -> str:
    """残り時間に応じて短くなっていく ASCII バー"""
    if duration_sec <= 0:
        ratio = 0.0
    else:
        ratio = remaining_sec / duration_sec
    # [0,1] にクランプ
    ratio = max(0.0, min(1.0, ratio))
    filled = int(width * ratio)
    # 見やすいようにブロック文字を使用（環境によっては # などに変えてもOK）
    return "█" * filled + " " * (width - filled)

def start_timer(hours=0, minutes=0, seconds=0):
    duration = timedelta(hours=hours, minutes=minutes, seconds=seconds)
    duration_sec = int(duration.total_seconds())
    if duration_sec <= 0:
        print("Duration must be positive.")
        return

    finish_at = datetime.now() + timedelta(seconds=duration_sec)
    save_state(finish_at, duration_sec)
    print(f"Timer started. It will finish at {finish_at}")
    run_timer_loop(finish_at, duration_sec)

def run_timer_loop(finish_at: datetime = None, duration_sec: int = None):
    # 再開時は引数が None のことがあるので、その場合は読み直す
    if finish_at is None or duration_sec is None:
        state = load_state()
        if state is None:
            print("No timer active.")
            return
        finish_at, duration_sec = state

    first_draw = True
    last_saved_minute = None

    try:
        while True:
            now = datetime.now()
            remaining = finish_at - now

            if remaining <= timedelta(0):
                # 最後に画面をきれいに更新してから終了
                if not first_draw:
                    print("\x1b[2F", end="")  # 2行上へ
                    print("\x1b[0J", end="")  # 下方向を消去
                print("Time's up! ☕ どうぞコーヒーをお楽しみください。")
                # 状態ファイルを消しておく
                try:
                    STATE_FILE.unlink(missing_ok=True)
                except Exception:
                    pass
                break

            total_sec = int(remaining.total_seconds())
            h = total_sec // 3600
            m = (total_sec % 3600) // 60
            s = total_sec % 60

            bar = format_bar(total_sec, duration_sec)

            if first_draw:
                # 初回はそのまま2行出力
                print(f"Remaining: {h:02d}:{m:02d}:{s:02d}")
                print(f"[{bar}]")
                first_draw = False
            else:
                # 2行分上にカーソルを戻して上書き
                print("\x1b[2F", end="")  # 2行上へ移動
                print("\x1b[0J", end="")  # そこから下を消去
                print(f"Remaining: {h:02d}:{m:02d}:{s:02d}")
                print(f"[{bar}]")

            # 1分に1回くらい現在時刻と終了時刻を保存
            if last_saved_minute != now.minute:
                save_state(finish_at, duration_sec)
                last_saved_minute = now.minute

            time.sleep(1)
    except KeyboardInterrupt:
        # Ctrl+C で止めたときも状態は残す（再開可）
        print("\nInterrupted by user. Timer state saved.")

def resume_timer():
    state = load_state()
    if state is None:
        print("No active timer.")
        return
    finish_at, duration_sec = state
    print(f"Resuming timer. It will finish at {finish_at}")
    run_timer_loop(finish_at, duration_sec)

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Coffee countdown timer")
    parser.add_argument(
        "--start",
        metavar="HH:MM:SS",
        help="Start a new timer with the given duration (e.g. 2:00:00)",
    )
    args = parser.parse_args()

    if args.start:
        try:
            h, m, s = map(int, args.start.split(":"))
        except ValueError:
            print("Invalid format. Use HH:MM:SS (e.g. 0:25:00)")
        else:
            start_timer(hours=h, minutes=m, seconds=s)
    else:
        # 引数なしなら再開
        resume_timer()
```

* * *

動作イメージ
------

ターミナルで：

```bash
python coffee_timer.py --start 2:00:00
```

とすると、ターミナル上で

```text
Remaining: 02:00:00
[██████████████████████████████]
```

のように 2 行表示されて、  
時間が減るにつれて下のバーが少しずつ短くなっていきます。

OS を再起動したあとで同じスクリプトを

```bash
python coffee_timer.py
```

と起動すると、`appdirs` のキャッシュディレクトリに保存しておいた `timer_state.json` を読み込んで残り時間を再計算します。再起動に 2 分かかっていれば、その 2 分もきちんと差し引かれて表示されます。

* * *

もし「バーの幅を変えたい」「カラーを付けたい（ANSI で緑→黄→赤にする）」などありましたら、そのあたりも調整版を書きます！

## Prompt:
コーヒーを取る回数を抑える用のタイマーなので、It will finish atより、Expires atのほうが良いでしょうか。

## Response:
はい、その用途なら **「Expires at」** の方が明確で自然です。  
「この時間まではコーヒー禁止（クールダウン中）」というニュアンスを持たせられるので、  
“finish” より “expire” の方が目的に合っています。

* * *

🔤 表記のニュアンス比較
-------------

| 表現 | ニュアンス | コーヒー制限タイマーに合う？ |
| --- | --- | --- |
| **Finish / Finished** | タスクが終わる、作業が完了する | ❌（やや機械的・完了作業向け） |
| **Ends at** | 期間が終わる | △（悪くない） |
| **Expires at** | 有効期限が切れる / 使用解禁になる | ◎（習慣管理・制限解除に最適） |
| **Unlocks at** | 解放される、使えるようになる | ◎（ゲーミフィケーション寄り） |

特に “Expires at” は  
**「クールダウンが切れる時刻」**  
というイメージがあり、コーヒー制限にぴったりです。

* * *

✏️ 例：メッセージを「Expires at」に変更
--------------------------

あなたのタイマーコードの該当部分は：

```python
print(f"Timer started. It will finish at {finish_at}")
```

ここを次のようにすると良いです：

```python
print(f"Timer started. Expires at {finish_at}")
```

再開時も：

```python
print(f"Resuming timer. Expires at {finish_at}")
```

* * *

☕ さらに「コーヒー解禁」を強調したい場合
---------------------

少し遊び心のあるバージョン：

```python
print(f"Coffee cooldown started. Expires at {finish_at}")
```

再開時：

```python
print(f"Cooldown active. Coffee unlocks at {finish_at}")
```

終了時：

```python
print("Cooldown expired! ☕ You may drink coffee now.")
```

* * *

必要なら、

*   日本語表示版
*   メッセージのローカライズ
*   「制限時間を延長する / 短縮する」コマンド
*   「1 日の最大杯数」を制限するバージョン  
    なども追加できます。

表現の最終調整もできますので、好みがあれば教えてください！

## Prompt:
ありがとうございます。あと、バーを長くしたいです。

## Response:
了解しました！バーを **もっと長く**して見やすくしたいのですね。  
既存コードの `format_bar()` はデフォルト 30 文字幅でしたが、これを **任意の長さに変更**できるように改良します。

* * *

🔧 バーを長くする方法
============

方法 1：単純に幅を変更（推奨）
----------------

バーの長さは `format_bar()` の `width` 引数で決まっています。

```python
def format_bar(remaining_sec: int, duration_sec: int, width: int = 30) -> str:
```

ここの `width=30` を例えば **60** に変更すれば、バーが倍の長さになります：

```python
def format_bar(remaining_sec: int, duration_sec: int, width: int = 60) -> str:
```

* * *

方法 2：ユーザー設定にしてコマンドラインから指定
-------------------------

より柔軟にしたい場合、`--width 60` のように指定できるようにします。

### 変更例

### 1) `format_bar` を width パラメータ付きで呼び出すように調整

```python
def format_bar(remaining_sec: int, duration_sec: int, width: int) -> str:
    if duration_sec <= 0:
        ratio = 0.0
    else:
        ratio = remaining_sec / duration_sec
    ratio = max(0.0, min(1.0, ratio))
    filled = int(width * ratio)
    return "█" * filled + " " * (width - filled)
```

### 2) `run_timer_loop()` に width を渡す

```python
def run_timer_loop(finish_at=None, duration_sec=None, width=60):
    ...
    bar = format_bar(total_sec, duration_sec, width)
```

### 3) argparse に追加

```python
parser.add_argument("--width", type=int, default=60, help="Width of the bar graph (default: 60)")
```

そして使う時は：

```bash
python coffee_timer.py --start 2:00:00 --width 80
```

* * *

☕ おすすめの長さ
=========

| 幅 | 見た目 | 用途 |
| --- | --- | --- |
| 60 | 実用的で見やすい | 普通のターミナル |
| 80 | フルHDターミナルに合う | 横幅に余裕 |
| 100–120 | 視覚的満足度が高い | ワイド画面、観賞用 |
| 150 以上 | かなり長い | グラフっぽい表示 |

* * *

🔥 例：幅60のバー
===========

↓

```
[██████████████████████████████████████████████████████                    ]
```

* * *

💬 他にも…
=======

*   減るにつれて色を **緑 → 黄 → 赤** に変える
*   二重バーにして「全体」と「今日の1杯目」など可視化
*   Unicode の太さ違い (`▉▊▋▌▍▎▏`) を使い滑らかにする
*   上に数字、下にバーという2行表示をもっと整える

などもできます。

「長さは○○くらいがいい」など具体的な要望があれば、最適化したバージョンを調整します！

## Prompt:
ありがとうございます。こういう感じで出るのですが、
秒以下の小数点は不要ですね
Resuming timer. Expires at 2025-12-02 21:06:00.375202

## Response:
了解しました！  
`datetime` の表示に **マイクロ秒（小数点以下）を含めない**ようにフォーマットを変更すれば解決します。

* * *

✅ 対策：`strftime` を使って秒までで切る
==========================

`finish_at` を文字列にするところを

```
{finish_at}
```

のようにデフォルト変換しているため、マイクロ秒が表示されています。

これを以下のように修正すると秒までのみ表示になります：

```python
finish_at.strftime("%Y-%m-%d %H:%M:%S")
```

* * *

🔧 修正箇所（2カ所）
============

① タイマー開始時
---------

元：

```python
print(f"Timer started. Expires at {finish_at}")
```

修正：

```python
print(f"Timer started. Expires at {finish_at.strftime('%Y-%m-%d %H:%M:%S')}")
```

* * *

② 再開時
-----

元：

```python
print(f"Resuming timer. Expires at {finish_at}")
```

修正：

```python
print(f"Resuming timer. Expires at {finish_at.strftime('%Y-%m-%d %H:%M:%S')}")
```

* * *

🔍 保存ファイルはそのままでOK？
==================

はい。  
`timer_state.json` に保存しているのは ISO 形式の `"2025-12-02T21:06:00.375202"` ですが、  
**内部表現はそのままで構いません**。

表示だけ秒までに整えれば十分です。

* * *

🎉 変更後の表示例
==========

```
Resuming timer. Expires at 2025-12-02 21:06:00
Remaining: 01:58:21
[███████████████████                     ]
```

すっきりしました！

* * *

必要なら：

*   日本語表示版
*   ターミナルにカラー（緑→黄→赤）
*   OS の通知（Linux: `notify-send`, macOS: `osascript`）
*   systemd サービス化

なども対応できますので、いつでも言ってください！

## Prompt:
ありがとうございます。あと、少しでもおしゃれなバーになるように、それっぽいライブラリをいくつか検索してみてください。

## Response:
いいですね。Python ターミナルで「もう少し“おしゃれ”なバー／表示」にしたいなら、既存の自作バーの代わりに、すでにある “装飾付きプログレスバーライブラリ” を使うのが手軽で効果があります。以下、いくつか有力なものを挙げます — 用途や好みに応じて選べると思います 👇

🎯 候補ライブラリ
----------

| ライブラリ名 | 特徴 / メリット |
| --- | --- |
| **rich** | カラー出力、装飾テキスト、テーブル表示、プログレスバーなど“ターミナル出力全体”をリッチにしてくれるライブラリ。バーの見た目や色を簡単に変えられて、CLI をカッコよくできます。[アメーバブログ（アメブロ）+2Qiita+2](https://ameblo.jp/fiender/entry-12884972236.html?utm_source=chatgpt.com) |
| **tqdm** | 最も手軽で広く使われているプログレスバー。ループに wrap するだけでバーが出る。バー幅や文字（`ascii`／Unicode）、色などもある程度カスタマイズ可能。[Qiita+2GitHub+2](https://qiita.com/shun_sakamoto/items/5462ca2ee6a5395ac6b2?utm_source=chatgpt.com) |
| **alive-progress** | 単なるバーではなく、アニメーションやスピナーも含めた“賑やかで動きのある”バー表示が可能。ちょっと遊び心を入れたいときに。[Qiita+2palmsub.rgr.jp+2](https://qiita.com/Hiroaki-K4/items/1239b7bab9ab02c9c381?utm_source=chatgpt.com) |

* * *

✅ 私ならどれを使うか — タイマー用途での提案
------------------------

*   シンプルかつ見やすさ重視 → `rich`  
    → 色付きで残り時間やバーを表示し、より洗練された CLI 表示に
*   軽く／依存少なめで → `tqdm`  
    → 手軽にバーを出したいならこれ。ただし「進捗処理向け」で、残り時間タイマー用途には自前制御がやや必要
*   遊び心・視覚効果重視 → `alive-progress`  
    → タイマーを「ちょっと楽しい見た目」にするならこれ。バーやスピナーを使って“待ち時間”を演出

* * *

🔄 既存コードへの適用イメージ（たとえば `rich`）
-----------------------------

たとえば `rich` を使うと、下記のようにかなり見た目が良くなります：

```python
from rich.console import Console
from rich.progress import Progress, BarColumn, TimeRemainingColumn

console = Console()

with Progress(
    "[progress.description]{task.description}",
    BarColumn(bar_width=60),
    TimeRemainingColumn(),
    console=console
) as prog:
    task = prog.add_task("Coffee cooldown", total=duration_sec)
    while not prog.finished:
        remaining = finish_at - datetime.now()
        remaining_sec = max(int(remaining.total_seconds()), 0)
        prog.update(task, completed=(duration_sec - remaining_sec))
        time.sleep(1)
```

こうすると、ターミナル上で「60 文字幅のバー + 残り時間表示 + カラー付き」で、かなり“それっぽい”見た目になります。

* * *

必要であれば、**3〜4個の候補ライブラリを使ったサンプル実装**を私のほうで書けます（たとえば `rich` 版 / `alive-progress` 版 / もとの ANSI 手書きバー版の比較コード付きで）。  
それを出してみますか？

## Prompt:
richのものをお願いします。

## Response:
思考時間: 57s

rich 版、いいですね。ターミナルが一気に “それっぽく” なります ☕  
`appdirs` で永続化しつつ、`rich` のプログレスバーで残り時間を表示するコードを用意しました。

* * *

事前準備
----

```bash
pip install rich appdirs
```

* * *

`coffee_timer_rich.py`（全文）
--------------------------

```python
import json
import time
from datetime import datetime, timedelta
from pathlib import Path

from appdirs import user_cache_dir
from rich.console import Console
from rich.progress import (
    Progress,
    BarColumn,
    TextColumn,
)

APP_NAME = "coffee_timer"
APP_AUTHOR = "toshihiro"  # お好みで

CACHE_DIR = Path(user_cache_dir(APP_NAME, APP_AUTHOR))
STATE_FILE = CACHE_DIR / "timer_state.json"

console = Console()

# ------------------------------
# 永続化まわり
# ------------------------------
def save_state(finish_at: datetime, duration_sec: int):
    """終了予定時刻と総時間、現在時刻をキャッシュに保存"""
    CACHE_DIR.mkdir(parents=True, exist_ok=True)
    now = datetime.now()
    data = {
        "finish_at": finish_at.isoformat(),
        "duration_sec": int(duration_sec),
        "last_saved_at": now.isoformat(),
    }
    STATE_FILE.write_text(json.dumps(data))

def load_state():
    """キャッシュから終了予定時刻と総時間を読み出す"""
    if not STATE_FILE.exists():
        return None
    try:
        data = json.loads(STATE_FILE.read_text())
        finish_at = datetime.fromisoformat(data["finish_at"])
        duration_sec = int(data["duration_sec"])
        return finish_at, duration_sec
    except Exception:
        return None

# ------------------------------
# タイマー本体
# ------------------------------
def start_timer(hours=0, minutes=0, seconds=0):
    duration = timedelta(hours=hours, minutes=minutes, seconds=seconds)
    duration_sec = int(duration.total_seconds())
    if duration_sec <= 0:
        console.print("[red]Duration must be positive.[/red]")
        return

    finish_at = datetime.now() + timedelta(seconds=duration_sec)
    save_state(finish_at, duration_sec)

    console.print(
        f"[bold cyan]Coffee cooldown started.[/bold cyan] "
        f"Expires at [yellow]{finish_at.strftime('%Y-%m-%d %H:%M:%S')}[/yellow]"
    )
    run_timer_loop(finish_at, duration_sec)

def run_timer_loop(finish_at: datetime = None, duration_sec: int = None):
    # resume 用に state から読み直すケース
    if finish_at is None or duration_sec is None:
        state = load_state()
        if state is None:
            console.print("[yellow]No active timer.[/yellow]")
            return
        finish_at, duration_sec = state

    # すでに期限切れなら即終了
    now = datetime.now()
    if (finish_at - now) <= timedelta(0):
        try:
            STATE_FILE.unlink(missing_ok=True)
        except Exception:
            pass
        console.print("[bold green]Cooldown already expired![/bold green] ☕")
        return

    last_saved_minute = None

    # rich の Progress を使ってバーを表示
    progress = Progress(
        TextColumn("[bold cyan]Coffee cooldown[/bold cyan]"),
        TextColumn("[white]{task.fields[remaining]}[/white]"),
        BarColumn(bar_width=60),
        transient=True,  # 終了後にバーを消す
        console=console,
    )

    try:
        with progress:
            task_id = progress.add_task(
                "",
                total=duration_sec,
                remaining="--:--:--",
            )

            while True:
                now = datetime.now()
                remaining = finish_at - now
                remaining_sec = int(remaining.total_seconds())

                if remaining_sec <= 0:
                    # 最後にバーを完了状態にして break
                    progress.update(
                        task_id,
                        completed=duration_sec,
                        remaining="00:00:00",
                    )
                    break

                # 経過時間 = 全体 - 残り
                completed = duration_sec - remaining_sec

                # 残り時間を HH:MM:SS に整形
                h = remaining_sec // 3600
                m = (remaining_sec % 3600) // 60
                s = remaining_sec % 60
                remaining_str = f"{h:02d}:{m:02d}:{s:02d}"

                progress.update(
                    task_id,
                    completed=completed,
                    remaining=remaining_str,
                )

                # 1分ごとに状態保存
                if last_saved_minute != now.minute:
                    save_state(finish_at, duration_sec)
                    last_saved_minute = now.minute

                time.sleep(1)

        # Progress コンテキストを抜けたあとにメッセージ表示
        try:
            STATE_FILE.unlink(missing_ok=True)
        except Exception:
            pass
        console.print("[bold green]Cooldown expired![/bold green] ☕ You may drink coffee now.")

    except KeyboardInterrupt:
        console.print("\n[yellow]Interrupted by user. Timer state saved.[/yellow]")

def resume_timer():
    state = load_state()
    if state is None:
        console.print("[yellow]No active timer.[/yellow]")
        return

    finish_at, duration_sec = state
    console.print(
        f"[bold cyan]Resuming cooldown.[/bold cyan] "
        f"Expires at [yellow]{finish_at.strftime('%Y-%m-%d %H:%M:%S')}[/yellow]"
    )
    run_timer_loop(finish_at, duration_sec)

# ------------------------------
# エントリポイント
# ------------------------------
if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Coffee cooldown timer (rich version)")
    parser.add_argument(
        "--start",
        metavar="HH:MM:SS",
        help="Start a new timer with the given duration (e.g. 2:00:00)",
    )
    args = parser.parse_args()

    if args.start:
        try:
            h, m, s = map(int, args.start.split(":"))
        except ValueError:
            console.print("[red]Invalid format. Use HH:MM:SS (e.g. 0:25:00).[/red]")
        else:
            start_timer(hours=h, minutes=m, seconds=s)
    else:
        # 引数なしなら再開
        resume_timer()
```

* * *

使い方
---

### 新しくタイマー開始

```bash
python coffee_timer_rich.py --start 2:00:00
```

ターミナルに

*   `Coffee cooldown 01:59:59 ███████…` のような **カラー付き1行表示**
*   時間が減るにつれてバーがだんだん短くなる

という表示になります。

### 再起動後に再開

```bash
python coffee_timer_rich.py
```

`appdirs` のキャッシュから `finish_at` を読み、  
再起動にかかった時間も含めて残り時間を再計算します。

* * *

もし

*   バーの色を「緑→黄→赤」に変える
*   「今日の◯杯目」を表示する
*   1日の総カフェイン上限管理もしたい

などあれば、その方向に拡張した版も作れます。

## Prompt:
![画像をアップロードしました](https://chatgpt.com/backend-api/estuary/content?id=file_00000000b04c720994d0913aa7a5eb47&ts=490184&p=fs&cid=1&sig=1804a0257c22443a3fb16a808a30b728e9d641afcdb117a11a26a1a18ec641a0&v=0)

ありがとうございます。伸びていくバーではなく、縮んでいくバーにしたいです。

## Response:
思考時間: 34s

いい感じに動いてますね！🥳  
今は「経過時間」を `completed` に入れているので、バーが **伸びていく** 形になっています。  
これを「残り時間」を `completed` に入れるようにすると、**だんだん縮んでいくバー** になります。

* * *

変更ポイントだけ（`run_timer_loop` 内）
----------------------------

今たぶんこんな感じになっていると思います：

```python
# 追加時
task_id = progress.add_task(
    "",
    total=duration_sec,
    remaining="--:--:--",
)

while True:
    ...
    remaining_sec = int(remaining.total_seconds())

    if remaining_sec <= 0:
        progress.update(
            task_id,
            completed=duration_sec,
            remaining="00:00:00",
        )
        break

    # ★ここ：経過時間を completed にしているので「伸びていく」バー
    completed = duration_sec - remaining_sec

    progress.update(
        task_id,
        completed=completed,
        remaining=remaining_str,
    )
```

これを **こう変更**してください：

```python
# 追加時（ここはそのままでOK）
task_id = progress.add_task(
    "",
    total=duration_sec,
    remaining="--:--:--",
)

while True:
    ...
    remaining_sec = int(remaining.total_seconds())

    if remaining_sec <= 0:
        # 残り 0 なので completed=0 として「バーが完全に消えた状態」に
        progress.update(
            task_id,
            completed=0,
            remaining="00:00:00",
        )
        break

    # ★変更：completed に「残り秒数」をそのまま入れる
    #   total=duration_sec に対して completed=remaining_sec なので、
    #   残りが減る → バーも短くなる
    completed = remaining_sec

    progress.update(
        task_id,
        completed=completed,
        remaining=remaining_str,
    )
```

*   `total = duration_sec`
*   `completed = remaining_sec`（最初は同じ → フルバー、だんだん 0 に近づく）

という関係になるので、

*   スタート直後：バーがフルに表示
*   時間が経つほど：バーが短くなっていく
*   残りゼロ：バーが消える（細い線だけ）

という挙動になります。

* * *

もし

*   「右側から削れてほしい」「色を途中で変えたい（最後は赤く）」
*   「バーが 0 になったあとも、薄い枠だけ残したい」

みたいな見た目の要望があれば、`BarColumn` に色指定やカスタムカラムを噛ませる形で、もう少し調整できます。

## Prompt:
ありがとうございます。長いときに赤いバーだというのも「今はまだ飲むな」という雰囲気が出ていて良いですね。これで完成といたします。

## Response:
よかったです！  
赤いバーのまま縮んでいくと、時間が減るほど“解禁が近づいていく”感じが出て、用途にぴったりですよね ☕🔥

また機能追加したくなったら、  
（例：1日○杯までの上限管理、コーヒー種別ごとのクールダウン、音付き通知、GUI版など）  
いつでも気軽に声をかけてください。

よいデカフェ生活を！



---
Powered by [ChatGPT Exporter](https://www.chatgptexporter.com)